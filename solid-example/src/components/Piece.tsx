/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import * as THREE from 'three'
import { GLTF } from 'three-stdlib'
import { ComponentProps, mergeProps, Show } from 'solid-js'
import { BISHOP, BLACK, KING, KNIGHT, PAWN, QUEEN, ROOK } from '../lib/chess'
import { useGLTF } from '../lib/useGLTF'
import { T } from 'solid-three'

type GLTFResult = GLTF & {
  nodes: {
    Rook: THREE.Mesh
    Queen: THREE.Mesh
    Bishop: THREE.Mesh
    King: THREE.Mesh
    Knight: THREE.Mesh
    Pawn: THREE.Mesh
  }
  materials: {
    white_piece: THREE.MeshStandardMaterial
    black_piece: THREE.MeshStandardMaterial
  }
}

const pieceMap = {
  [PAWN]: 'Pawn',
  [ROOK]: 'Rook',
  [QUEEN]: 'Queen',
  [KING]: 'King',
  [KNIGHT]: 'Knight',
  [BISHOP]: 'Bishop',
} as const

export function Piece(props) {
  props = mergeProps(
    {
      piece: QUEEN,
      color: BLACK,
      square: 'a1',
      position: [0, 0, 0],
    },
    props,
  )

  // const controls = useControls("piece", {
  //   color: folder({ black: "#414141", white: "#c4bdbd" })
  // });

  const controls = { black: '#222222', white: '#c4bdbd' }

  // const object = useTheatreControls("piece", {
  //   y: 0,
  //   rotateY: -Math.PI / 2
  // });

  // const [x, y, z] = position;

  // const ref = React.useRef<THREE.Object3D>();

  // useFrame(() => {});

  // const [isSquareHovered, setIsSquareHovered] = useAtom(
  //   $.isHoveredSquare(square)
  // );

  // const [selectedSquare, setSelectedSquare] = useAtom($.selectedSquare);
  // const isSelected = selectedSquare === square;
  // const [_, bind] = useHover({
  //   onPointerEnter: (e) => {
  //     setIsSquareHovered(true);
  //   },
  //   onPointerLeave: (e) => {
  //     setIsSquareHovered(false);
  //   },
  // });
  // const turn = useAtomValue($.turn);
  // const isSelectable = color === turn;

  // const { spring: hoverSpring } = useSpring({
  //   spring: (isSquareHovered && isSelectable) || isSelected ? 1 : 0,
  //   config: { mass: 5, tension: 400, friction: 50, precision: 0.0001 },
  // });

  // const positionY = hoverSpring.to([0, 1], [y, y + 0.3]);
  // const rotationY = hoverSpring.to([0, 1], [0, 0.5]);

  return (
    <T.Group
      position={props.position}
      // rotation-y={object.rotateY}
    >
      <PieceModel
        // {...bind}
        piece={pieceMap[props.piece]}
        onPointerDown={() => {
          // if (color === turn) {
          //   setSelectedSquare(square);
          // }
        }}
        scale={0.5}
        rotation={[
          -Math.PI / 4,
          0,
          0,
          // props.color === BLACK ? (5 / 4) * Math.PI : Math.PI / 4
        ]}
        // material={props.color === BLACK ? "black_piece" : "white_piece"}
        // {...props}
      >
        <T.MeshLambertMaterial reflectivity={10} color={props.color === BLACK ? controls.black : controls.white} />
      </PieceModel>
    </T.Group>
  )
}

type PieceType = keyof GLTFResult['nodes']

export function PieceModel(
  props: ComponentProps<typeof T.Group> & {
    piece: PieceType
    material?: keyof GLTFResult['materials']
  },
) {
  // const group = THREE.Group!;
  const data = useGLTF<GLTFResult>('/low_poly_chess_set/pieces.glb')

  return (
    <T.Group {...props}>
      <T.Group name="Piece">
        <Show when={data()} fallback={null}>
          <T.Mesh
            name={props.piece}
            castShadow
            receiveShadow
            rotation={props.rotation}
            geometry={data()?.nodes[props.piece].geometry}
            {...(props.material ? { material: data()?.materials[props.material] } : {})}
            userData={{ name: props.piece }}>
            {props.children}
          </T.Mesh>
        </Show>
      </T.Group>
    </T.Group>
  )
}

// useGLTF.preload("/low_poly_chess_set/pieces.glb");
